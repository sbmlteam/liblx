Quickstart
==========

.. _building_library:

Building the library
--------------------
There are different components we can build:
- the C++ liblx library
- the SWIG language bindings (e.g. enable access to liblx via a Python interface)
- the documentation

It is best to do an "out-of-source" build. This means to build the components in a
location which is not within the cmake hierarchy being used. A quick way of doing
this is to create a new ``build/`` directory, ensuring it is not within the liblx
github repo which you have cloned.

Also, note that, at the current time, you can choose which of three different XML libraries
you wish to use to build ``liblx``.

.. _building_mac:

Instructions for building on a Mac
----------------------------------

If you want to build the SWIG language bindings, install swig e.g. ``brew install swig``

In order to be able to run the test code, install check (unit testing library for C) -
e.g. ``brew install check``  -> ``/usr/local/Cellar/check/0.15.2/`` in my case.

Now clone the liblx repo in a suitable directory, if not done already:

``git clone https://github.com/sbmlteam/liblx.git``

#In my case, it creates /Users/matthewgillman/repos/libLX/liblx/ when I do this command in /Users/matthewgillman/repos/libLX/

In a location outside of the cloned repo, create a directory in which to do the build, e.g.
 ``mkdir build``   -  the results of the build will be in here.
 ``cd build``
 Execute ``cmake``, e.g.

.. code-block:: bash

 cmake -DCMAKE_BUILD_TYPE:STRING=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON -DCMAKE_VERBOSE_MAKEFILE:BOOL=ON -DWITH_CHECK=TRUE -G "Unix Makefiles" /path/to/liblx/cloned/repo/

Note that the directory at the end of the cmake command above is the top-level directory of the cloned repo
(i.e. it contains the top-level ``CMakeLists.txt`` file).

Now execute command ``make``, or try ``cmake --build .``

On Mac, this builds ``build/src/liblx-static.a`` and ``build/src/liblx.dylib``

Invoke test script in ``build/`` subdir; it is ``src/liblx/xml/test/test_sbml_xml``
I think executing the command ``ctest -V`` has the same effect (TBC).

If you do a build with the extra switch ``-DWITH_PYTHON=TRUE``, you should find Python bindings generated in the build directory,
in ``src/bindings/python``. Frank says: "you should find the ``libsbml.py`` (or ``libsbml2.py / libsbml3.py`` since we still support both
versions). along with a native library ``libsbml.pyd|so|dylib``. At that point you can change into the directory, export
the ``PYTHONPATH`` variable to the current path, and you can import ``libsbml`` with the configured python interpreter.
you can run ctest to check all tests pass.

NB TBC: Python bindings are ``liblx.py``, rather than ``libsbml.py``??

each time you build, it is best to delete any results of the previous build
``git clean`` can remove untracked files e.g. those generated by ``CMake`` - need to clean these out before
each ``CMake`` build
e.g.

.. code-block:: bash

     git clean -d -x -f -n  # check what you will delete
     git clean -d -x -f
     mkdir build
     cd build
     cmake -DWITH_PYTHON=TRUE -DCMAKE_BUILD_TYPE:STRING=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON -DCMAKE_VERBOSE_MAKEFILE:BOOL=ON -DWITH_CHECK=TRUE -G "Unix Makefiles" /Users/matthewgillman/repos/libLX/liblx/
     make

or use the nuclear option: ``rm -rf build/*``

To get the SWIG/Python bindings built, it appears we must download the Xerces distribution.
Because various Xerces files in ``src/liblx/xml`` ``#include`` files from there.
LibXML appears to be fully present already
Instructions at http://www.yolinux.com/TUTORIALS/XML-Xerces-C.html

.. code-block:: bash

    > cd ~
    > mkdir xerces && cd xerces
    http://xml.apache.org/xerces-c/download.cgi
    e.g.:
    > wget https://www.mirrorservice.org/sites/ftp.apache.org//xerces/c/3/sources/xerces-c-3.2.3.tar.gz
    > shasum *.gz   # check the output is the same as on the xerces website download page
    > tar -xzf xerces-c-3.2.3.tar.gz
    > cd xerces-c-3.2.3
    > ./configure --prefix=/opt
    > make
    > sudo make install

The include files are now in ``/opt/include/xercesc``, new applications in ``/opt/bin``,
and libraries in ``/opt/lib``.
This will install development files such as include header files and libraries in "/opt" so compiler flags and linker flags are required:

    Compiler flags: ``-I/opt/include``         (``CXXFLAGS``)
    Linker flags: ``-L/opt/lib -lxerces-c``    (``LDFLAGS``)
try: cmake command as above but with ``-I/opt/include -L/opt/lib -lxerces-c``

should be able to do this:

.. code-block:: bash

     cmake ... -DWITH_XERCES=TRUE  (or -DWITH_EXPAT or -DWITH_LIBXML)

Actually, ``WITH_LIBXML`` is ``ON`` by default, so would need:

.. code-block:: bash

     cmake ... -DWITH_XERCES=TRUE -DWITH_LIBXML=FALSE (or ON/OFF)

# I think this statement is wrong (TBC):
NB at the moment Expat and Xerces builds are failing as they still have some SBML stuff
e.g. ``LIBSBML_CPP_NAMESPACE_END``


.. _how_to_use_SWIG_Python_binding:

Example of how to use the SWIG/Python binding
---------------------------------------------
Still in the ``/build`` directory, set the ``PYTHONPATH`` environment variable. e.g. on Mac:

.. code-block:: bash

     export PYTHONPATH=.:src/bindings/python

or, on Windows:

.. code-block:: bash

     set PYTHONPATH=.;src/bindings/python

Now we can fire up a Python interpreter and use ``liblx``:

.. code-block:: bash

    python
    >>> from liblx import *
    >>> test_str = "<annotation>\n" + "  <test xmlns=\"http://test.org/\" id=\"test1\">test2</test>\n" + "</annotation>"
    >>> y = XMLNode(test_str)
    >>> print(y.toString())
    <annotation>
      <test xmlns="http://test.org/" id="test1">test2</test>
    </annotation>
    >>> z = y.clone()
    >>> print(z)
    <liblx.XMLNode; proxy of <Swig Object of type 'XMLNode_t *' at 0x7fe15437d870> >
    >>> print(z.toString())
    <annotation>
      <test xmlns="http://test.org/" id="test1">test2</test>
    </annotation>
    >>> y == z
    False
    >>> y is z
    False
    >>> y.toString() == z.toString()
    True
    >>> y.equals(z)
    True
    >>> z.equals(y)
    True
    >>> print(y.toXMLString())
    &lt;annotation&gt;
      &lt;test xmlns=&quot;http://test.org/&quot; id=&quot;test1&quot;&gt;test2&lt;/test&gt;
    &lt;/annotation&gt;


.. _building_windows:

How to build on Windows
-----------------------
You need to install:

 -  `Visual Studio <https://visualstudio.microsoft.com/vs/>`_  (I included the Windows 10 SDK)
    In my case this was Microsoft Visual Studio Community 2019, Version 16.11.1


 -  `CMake <https://cmake.org/download/>`_. I  chose the Windows installer and checked the box to update PATH.

You then need to download the `SBML Windows dependencies <https://sourceforge.net/projects/sbml/files/libsbml/win-dependencies/>`_.
This contains a number of libraries used by SBML, and by `liblx` too.
Right now there is no "version 16", so I downloaded the highest available one (15), using the debug
version as I am working on the core `liblx`. Make sure you check the checksums
The version I downloaded, when unzipped, created a directory which had a space in the name, and a quote mark
at each end. For simplicity, I renamed it:
mv 'libSBML Dependencies-1.0.0-b1-win64' libSBML-Dependencies-1.0.0-b1-win64
or, in Windows cmd shell window:

  ``rename "libSBML Dependencies-1.0.0-b1-win64" libSBML-Dependencies-1.0.0-b1-win64``

It is best to use a virtual environment, as per the Mac instructions.

Then create a new build/ directory; I did mine inside the liblx directory cloned from Github.
Then, from within that new build directory, in a Visual Studio Command Prompt:

  ``cmake -DLIBLX_DEPENDENCY_DIR=C:\Users\mattg\repos\work\CompBioLibs\libSBML-Dependencies-1.0.0-b1-win64 -DCMAKE_BUILD_TYPE=Release -DWITH_STATIC_RUNTIME=ON ..``

better: out-of-source build - commands invoked from new directory c:\Users\mattg\build:

.. code-block:: bash

     cmake -DLIBLX_DEPENDENCY_DIR=C:\Users\mattg\repos\work\CompBioLibs\debug\debug_x64_dynamic\libSBML-Dependencies-1.0.0-b1-win64 -DCMAKE_BUILD_TYPE=Debug -DWITH_CHECK=TRUE -DCMAKE_BUILD_TYPE=Release -DWITH_STATIC_RUNTIME=OFF C:\Users\mattg\repos\work\CompBioLibs\liblx
     cmake --build .

-> in build\src\Debug, got liblx-static.lib and liblx.dll
Seems to generate both static and dynamic libs regardless.
 ctest -V

NB CMake has a GUI you can fire up and use instead, if you want.

The `LIBLX_DEPENDENCY_DIR` is the absolute path to the unzipped (and renamed) folder.

There are some `detailed instructions <http://sbml.org/Software/libSBML/5.18.0/docs/cpp-api/libsbml-installation.html#detailed-windows>`_ for building libSBML on Windows (which we can adapt for building liblx).

Once `cmake` has finished, and thus configured the project, it is time to run the C++ build itself.
The easiest way is to locate the "solution" file, liblx.sln, which should have been generated in the `build` directory;
navigate to it using Windows Explorer, then double-click on it to open this solution in Visual Studio (but see below).
Then, right-click on the desired target (e.g. `ALL_BUILD`) and select the build option.
All being well, you should find the library files `liblx.dll` and `liblx-static.lib` have been generated;
in my case, in `build/src/Debug/`. NB not sure why dll built as well as static lib.
  

$ ls -lh build/src/Debug
total 32M
-rwxr-xr-x 1 mattg 197611 2.7M Aug 26 11:24 liblx.dll*
-rw-r--r-- 1 mattg 197611 168K Aug 26 11:24 liblx.exp
-rw-r--r-- 1 mattg 197611 274K Aug 26 11:24 liblx.lib
-rw-r--r-- 1 mattg 197611  13M Aug 26 11:24 liblx.pdb
-rw-r--r-- 1 mattg 197611  17M Aug 26 11:24 liblx-static.lib

Alternatively, you can build it from the command-line.

.. _building_documentation:

Building the documentation
--------------------------
The documentation is automatically built on readthedocs with every commit. However, you
can still generate the documentation locally along your normal build (see `Building the library`_). For that you
will need the following requirements installed:

  * doxygen <https://www.doxygen.nl>
  * python3

Next you need the following python packages ``breathe`` and ``sphinx_rtd_theme``. So we start
by creating a virtual environment, activating it and installing the packages into it. 

.. code-block:: bash

    ~ > python3 -m venv venv 
    ~ > . ./venv/bin/activate
    (venv) ~ > pip install sphinx_rtd_theme breathe
    (venv) ~ > brew install doxygen

NB the above steps should not be done in the directory hierarchy of the git repo.

On Windows, VS cmd prompt:
python -m venv venv
.\venv\Scripts\activate   -> you should see command prompt text change
>pip install sphinx_rtd_theme breathe
Install Doxygen binaries - see https://www.doxygen.nl/manual/install.html#install_bin_windows
and GraphViz - see https://graphviz.org/download/
Update PATH e.g. set PATH=%PATH%;C:\Program Files\doxygen\bin  (or setx to do it permanently)
set PATH=%PATH%;C:\Program Files\GraphViz\bin

From a website with instructions (https://devblogs.microsoft.com/cppblog/clear-functional-c-documentation-with-sphinx-breathe-doxygen-cmake/)
: "Breathe is the bridge between Doxygen and Sphinx; taking the output from the former and making it available through some
special directives in the latter."

The command ``pip show breathe`` will show whereabouts on your system ``breathe`` has been installed.
This location needs to be added to your ``PYTHONPATH`` before building the documentation
(or, if ``PYTHONPATH`` is not currently set, to set it to this value).
For example, if the ``breathe`` directory is installed as ``/Users/smith/venv/lib/python3.6/site-packages/breathe``,
add ``/Users/smith/venv/lib/python3.6/site-packages/`` to your ``PYTHONPATH``. For example:

.. code-block:: bash

    > export PYTHONPATH="/Users/smith/venv/lib/python3.6/site-packages/"
    > echo $PYTHONPATH
    /Users/smith/venv/lib/python3.6/site-packages/

or, on Windows:

.. code-block:: bash

    > set PYTHONPATH=C:\Users\mattg\envts\venv\lib\site-packages

(We created venv inside directory C:\Users\mattg\envts before this)

Since the documentation is not generated by default, you have to reconfigure your cmake
project for the libLX API next. So change into your build folder from before, and
reconfigure with the option ``-DWITH_DOXYGEN=ON``.

You need to set the ``CODE_SRC_DIR`` environment variable; this specifies the location of the top
of the hierarchy of liblx source files in the repo. Example (Windows):

.. code-block:: bash

     > set CODE_SRC_DIR=C:\Users\mattg\repos\work\CompBioLibs\liblx\src

This will allow the "API" section of the documentation to be populated.

.. code-block:: bash

    (venv) ~ > cd liblx/build
    (venv) build > cmake -DWITH_DOXYGEN=ON ..

    ...
    ...
    -- Configuring done
    -- Generating done
    -- Build files have been written to: /some/path/or/other/build
    (venv) build >

Errors would have shown if Doxygen or Sphinx could not be found in the process. Now you
are ready to build the documentation with: 

.. code-block:: bash

    (venv) build > make Sphinx
    [ 50%] Generating documentation with Sphinx
    Running Sphinx v3.5.4

    .... add sample output here .....

    build succeeded.

    The HTML pages are in sphinx.
    [100%] Built target Sphinx

    (venv) build >

And at this point you have the HTML pages generated in ``./docs/sphinx/`` with the 
main document being ``./docs/sphinx/index.html``

Windows example (builds docs and check code):

cmake -DLIBLX_DEPENDENCY_DIR=C:\Users\mattg\repos\work\CompBioLibs\debug\debug_x64_dynamic\libSBML-Dependencies-1.0.0-b1-win64 -DCMAKE_BUILD_TYPE=Debug -DWITH_CHECK=TRUE -DCMAKE_BUILD_TYPE=Release -DWITH_STATIC_RUNTIME=OFF -DWITH_DOXYGEN=TRUE  C:\Users\mattg\repos\work\CompBioLibs\liblx
cmake --build .
ctest -V

Doxygen should be picked up, if you updated the ``PATH`` environment variable above; if not,
you can specify it as an extra item in the ``cmake`` command above.
e.g. ``-DDOXYGEN_EXECUTABLE="C:\Program Files\doxygen\bin\doxygen.exe"``


Running the tests
-----------------
We use the testing framework catch2 <https://github.com/catchorg/Catch2> and 
integrated it with the cmake build, so after building the library you can run 
the tests using ``ctest``:

.. code-block:: bash

    (venv) build > ctest -V     (or -v if you want less output)

If you want to run tests on another build configuration, you can specify those
using the ``-C`` option. So for example for the debug build:

.. code-block:: bash

    (venv) build > ctest -C Debug -V

