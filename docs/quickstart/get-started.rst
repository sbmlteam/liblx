Quickstart
==========

.. _building_library:

Building the library
--------------------
Add notes here from `instructions.txt`, including how to build with the different XML libraries,
how to build with test and check C library, how to build SWIG Python bindings, etc.
This section must mention a `build/` folder. Best to do an out-of-source build.


.. _building_mac:

Instructions for building on a Mac.
==================================

1. install swig e.g. brew install swig
2. install check (unit testing library for C) - e.g. brew install check  -> /usr/local/Cellar/check/0.15.2/
3. git clone https://github.com/sbmlteam/liblx.git    (in a suitable directory).
In my case, it creates /Users/matthewgillman/repos/libLX/liblx/ when I do this command in /Users/matthewgillman/repos/libLX/
4. cd liblx
5. mkdir build   -  the results of the build will be in here.
6. cd build
7. cmake -DCMAKE_BUILD_TYPE:STRING=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON -DCMAKE_VERBOSE_MAKEFILE:BOOL=ON -DWITH_CHECK=TRUE -G "Unix Makefiles" /Users/matthewgillman/repos/libLX/liblx/
Note that the directory at the end of the cmake command above is the top-level directory of the cloned repo (i.e. it contains the top-level CMakeLists.txt file).
8. make
9. invoke test script In my build subdir, it is src/liblx/xml/test/test_sbml_xml
On Mac, this builds build/src/liblx-static.a and build/src/liblx.dylib


If you do a build with the extra switch -DWITH_PYTHON=TRUE, you should find Python bindings generated in the build directory,
in src/bindings/python. Frank: you should find the libsbml.py (or libsbml2.py / libsbml3.py since we still support both
versions). along with a native library _libsbml.pyd|so|dylib. At that point you can change into the directory, export
the PYTHONPATH variable to the current path, and you can import libsbml with the configured python interpreter.
you can run ctest to check all tests pass.

git clean can remove untracked files e.g. those generated by CMake - need to clean these out before
each CMake build
e.g.
git clean -d -x -f -n  # check what you will delete
git clean -d -x -f
mkdir build
cd build
cmake -DWITH_PYTHON=TRUE -DCMAKE_BUILD_TYPE:STRING=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON -DCMAKE_VERBOSE_MAKEFILE:BOOL=ON -DWITH_CHECK=TRUE -G "Unix Makefiles" /Users/matthewgillman/repos/libLX/liblx/
make

To get the SWIG/Python bindings built, it appears we must download the Xerces distribution.
Because various Xerces files in src/liblx/xml #include files from there.
LibXML appears to be fully present already
Instructions at http://www.yolinux.com/TUTORIALS/XML-Xerces-C.html
> cd ~
> mkdir xerces && cd xerces
http://xml.apache.org/xerces-c/download.cgi
e.g.:
> wget https://www.mirrorservice.org/sites/ftp.apache.org//xerces/c/3/sources/xerces-c-3.2.3.tar.gz
> shasum *.gz   # check the output is the same as on the xerces website download page
> tar -xzf xerces-c-3.2.3.tar.gz
> cd xerces-c-3.2.3
> ./configure --prefix=/opt
> make
> sudo make install
The include files are now in  /opt/include/xercesc, new applications in /opt/bin, and libraries in /opt/lib
This will install development files such as include header files and libraries in "/opt" so compiler flags and linker flags are required:

    Compiler flags: -I/opt/include         CXXFLAGS
    Linker flags: -L/opt/lib -lxerces-c    LDFLAGS
try: cmake command as above but with -I/opt/include -L/opt/lib -lxerces-c
should be able to do this:
cmake ... -DWITH_XERCES=TRUE  (or -DWITH_EXPAT or -DWITH_LIBXML)
actually WITH_LIBXML is ON by default, so would need cmake ... -DWITH_XERCES=TRUE -DWITH_LIBXML=FALSE (or ON/OFF)

NB at the moment Expat and Xerces builds are failing as they still have some SBML stuff e.g. LIBSBML_CPP_NAMESPACE_END

example of variables:
${CMAKE_CURRENT_SOURCE_DIR} = /Users/matthewgillman/repos/libLX/liblx/src
${CMAKE_CURRENT_BINARY_DIR} = /Users/matthewgillman/repos/libLX/liblx/build/src

====================

.. _how_to_use_SWIG_Python_binding:

Example of how to use the SWIG/Python binding
---------------------------------------------
Still in the `/build` directory
`export PYTHONPATH=.:src/bindings/python`

python
>>> from liblx import *
>>> test_str = "<annotation>\n" + "  <test xmlns=\"http://test.org/\" id=\"test1\">test2</test>\n" + "</annotation>"
>>> y = XMLNode(test_str)
>>> print(y.toString())
<annotation>
  <test xmlns="http://test.org/" id="test1">test2</test>
</annotation>
>>> z = y.clone()
>>> print(z)
<liblx.XMLNode; proxy of <Swig Object of type 'XMLNode_t *' at 0x7fe15437d870> >
>>> print(z.toString())
<annotation>
  <test xmlns="http://test.org/" id="test1">test2</test>
</annotation>
>>> y == z
False
>>> y is z
False
>>> y.toString() == z.toString()
True
>>> y.equals(z)
True
>>> z.equals(y)
True
>>> print(y.toXMLString())
&lt;annotation&gt;
  &lt;test xmlns=&quot;http://test.org/&quot; id=&quot;test1&quot;&gt;test2&lt;/test&gt;
&lt;/annotation&gt;


.. _building_windows:

How to build on Windows
-----------------------
You need to install:

 -  `Visual Studio <https://visualstudio.microsoft.com/vs/>`_  (I included the Windows 10 SDK)
    In my case this was Microsoft Visual Studio Community 2019, Version 16.11.1


 -  `CMake <https://cmake.org/download/>`_. I  chose the Windows installer and checked the box to update PATH.

You then need to download the `SBML Windows dependencies <https://sourceforge.net/projects/sbml/files/libsbml/win-dependencies/>`_.
This contains a number of libraries used by SBML, and by `liblx` too.
Right now there is no "version 16", so I downloaded the highest available one (15), using the debug
version as I am working on the core `liblx`. Make sure you check the checksums
The version I downloaded, when unzipped, created a directory which had a space in the name, and a quote mark
at each end. For simplicity, I renamed it:
mv 'libSBML Dependencies-1.0.0-b1-win64' libSBML-Dependencies-1.0.0-b1-win64
or, in Windows cmd shell window:

  rename "libSBML Dependencies-1.0.0-b1-win64" libSBML-Dependencies-1.0.0-b1-win64

Then create a new build/ directory; I did mine inside the liblx directory cloned from Github.
Then, from within that new build directory, in a Visual Studio Command Prompt:

  cmake -DLIBLX_DEPENDENCY_DIR=C:\Users\mattg\repos\work\CompBioLibs\libSBML-Dependencies-1.0.0-b1-win64 -DCMAKE_BUILD_TYPE=Release -DWITH_STATIC_RUNTIME=ON ..

NB CMake has a GUI you can fire up and use instead, if you want.

The LIBLX_DEPENDENCY_DIR is the absolute path to the unzipped (and renamed) folder.

There are some `detailed instructions <http://sbml.org/Software/libSBML/5.18.0/docs/cpp-api/libsbml-installation.html#detailed-windows>`_ for building libSBML on Windows (which we can adapt for building liblx).

Once `cmake` has finished, and thus configured the project, it is time to run the C++ build itself.
The easiest way is to locate the "solution" file, liblx.sln, which should have been generated in the `build` directory;
navigate to it using Windows Explorer, then double-click on it to open this solution in Visual Studio.
Then, right-click on the desired target (e.g. `ALL_BUILD`) and select the build option.
All being well, you should find the library file `liblx.dll` has been generated; in my case, in `build/src/Debug/`.
  

$ ls -lh build/src/Debug
total 32M
-rwxr-xr-x 1 mattg 197611 2.7M Aug 26 11:24 liblx.dll*
-rw-r--r-- 1 mattg 197611 168K Aug 26 11:24 liblx.exp
-rw-r--r-- 1 mattg 197611 274K Aug 26 11:24 liblx.lib
-rw-r--r-- 1 mattg 197611  13M Aug 26 11:24 liblx.pdb
-rw-r--r-- 1 mattg 197611  17M Aug 26 11:24 liblx-static.lib



.. _building_documentation:

Building the documentation
--------------------------
The documentation is automatically built on readthedocs with every commit. However, you
can still generate the documentation locally along your normal build (see `Building the library`_). For that you
will need the following requirements installed:

  * doxygen <https://www.doxygen.nl>
  * python3

Next you need the following python packages ``breathe`` and ``sphinx_rtd_theme``. So we start
by creating a virtual environment, activating it and installing the packages into it. 

.. code-block:: bash

    ~ > python3 -m venv venv 
    ~ > . ./venv/bin/activate
    (venv) ~ > pip install sphinx_rtd_theme breathe
    (venv) ~ > brew install doxygen

The command ``pip show breathe`` will show whereabouts on your system ``breathe`` has been installed.
This location needs to be added to your ``PYTHONPATH`` before building the documentation.
For example, if the ``breathe`` directory is installed as ``/Users/smith/venv/lib/python3.6/site-packages/breathe``,
add ``/Users/smith/venv/lib/python3.6/site-packages/`` to your ``PYTHONPATH``. For example:

.. code-block:: bash

    > export PYTHONPATH="/Users/smith/venv/lib/python3.6/site-packages/"
    > echo $PYTHONPATH
    /Users/smith/venv/lib/python3.6/site-packages/


Since the documentation is not generated by default, you have to reconfigure your cmake
project for the libLX API next. So change into your build folder from before, and
reconfigure with the option ``-DWITH_DOXYGEN=ON``.

.. code-block:: bash

    (venv) ~ > cd liblx/build
    (venv) build > cmake -DWITH_DOXYGEN=ON ..

    add some typical cmake output here

    ...
    -- Configuring done
    -- Generating done
    -- Build files have been written to: /some/path/or/other/build
    (venv) build >

Errors would have shown if Doxygen or Sphinx could not be found in the process. Now you
are ready to build the documentation with: 

.. code-block:: bash

    (venv) build > make Sphinx
    [ 50%] Generating documentation with Sphinx
    Running Sphinx v3.5.4

    .... add sample output here .....

    build succeeded.

    The HTML pages are in sphinx.
    [100%] Built target Sphinx

    (venv) build >

And at this point you have the HTML pages generated in ``./docs/sphinx/`` with the 
main document being ``./docs/sphinx/index.html``

Running the tests - check the next line is correct.
-----------------
We use the testing framework catch2 <https://github.com/catchorg/Catch2> and 
integrated it with the cmake build, so after building the library you can run 
the tests using ``ctest``:

.. code-block:: bash

    (venv) build > ctest -V

If you want to run tests on another build configuration, you can specify those
using the ``-C`` option. So for example for the debug build:

.. code-block:: bash

    (venv) build > ctest -C Debug -V     # check this is true for liblx




The following is specific to COPASI. Add liblx details as appropriate...
========================================================================



You can also run the test binary directly, but in that case test files provided in
``./tests/test-data`` will not be automatically found, as the source dir is not known. 

.. code-block:: bash

    (venv) build > ./tests/test_api
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    test_api.exe is a Catch v1.5.6 host application.
    Run with -? for options

    -------------------------------------------------------------------------------
    load copasi file and access via regular COPASI api
    -------------------------------------------------------------------------------
    /copasi-api/tests/TestCore.cpp(32)
    ...............................................................................

    /copasi-api/tests/TestCore.cpp(38): FAILED:
    REQUIRE( dm->loadModel(fileName, 0) == true )
    with expansion:
        false == true

    ===============================================================================
    test cases:  2 |  1 passed | 1 failed
    assertions: 22 | 21 passed | 1 failed

In that case you can specify an environment variable ``srcdir`` pointing to it: 

.. code-block:: bash

    (venv) build > srcdir=/copasi-api/tests ./tests/test_api
    ===============================================================================
    All tests passed (24 assertions in 2 test cases)

Additional options of the test runner: 

.. code-block:: bash

    (venv) build > ./tests/test_api -?
    Catch v1.5.6
    usage:
        test_api [<test name, pattern or tags> ...] [options]

    where options are:
        -?, -h, --help               display usage information
        -l, --list-tests             list all/matching test cases
        -t, --list-tags              list all/matching tags
        -s, --success                include successful tests in output
        -b, --break                  break into debugger on failure
        -e, --nothrow                skip exception tests
        -i, --invisibles             show invisibles (tabs, newlines)
        -o, --out <filename>         output filename
        -r, --reporter <name>        reporter to use (defaults to console)
        -n, --name <name>            suite name
        -a, --abort                  abort at first failure
        -x, --abortx <no. failures>  abort after x failures
        -w, --warn <warning name>    enable warnings
        -d, --durations <yes|no>     show test durations
        -f, --input-file <filename>  load test names to run from a file
        -#, --filenames-as-tags      adds a tag for the filename
        --list-test-names-only       list all/matching test cases names only
        --list-reporters             list all reporters
        --order <decl|lex|rand>      test case order (defaults to decl)
        --rng-seed <'time'|number>   set a specific seed for random numbers
        --force-colour               force colourised output (deprecated)
        --use-colour <yes|no>        should output be colourised
